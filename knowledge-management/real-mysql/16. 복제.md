
# 개요
복제는 한 서버에서 다른 서버로 데이터가 동기화되는 것을 말한다.
- 원본 데이터를 가진 서버 = 소스 서버
- 복제된 데이터를 가지는 서버 = 레플리카 서버


복제를 하는 이유
- 쿼리 분산을 통한 트래픽 대응을 위한 방법으로 스케일 아웃을 시키기 위해
- 데이터 백업으로 인한 영향이 서비스로 번지는 것을 막기위해 레플리카 서버에서 백업을 시도한다.
- 데이터 분석 환경을 따로 마련하기 위해
- DB 서버를 어플리케이션 서버와 최대한 가깝게 두기 위해, 만약 소스 서버에 제약이 있다면 레플리카 서버를 가까히 둔다.


# 복제 아키텍처 #anki
MySQL 서버에서 발생하는 모든 변경사항은 '이벤트'라는 이름으로 '바이너리 로그 파일'에 순서대로 저장된다.
바이너리 로그에는 다음 변경 정보들이 모두 저장된다.
- 데이터 변경 내역
- 테이블 구조 변경
- 계정 및 권한 변경

MySQL 복제는 바이너리 로그 파일을 동기화하는 방식으로 구현되어있다.
![[Pasted image 20221031004606.png]]

복제는 아래 스레드에 의해 동작한다.
- 바이너리 로그 스레드 (트랜잭션 처리 스레드)
- 바이너리 로그 덤프 스레드 : 레플리카 서버로 이벤트를 보내는 역할. 레플리카 서버로 보낼 각 이벤트를 읽을 때 일시적으로 바이너리 로그에 잠금을 수행하며, 이벤트를 읽고난 후에는 바로 잠금을 해제한다.
- Replica I/O 스레드 : 소스 서버의 바이너리 로그 덤프 스레드로부터 바이너리 로그 이벤트를 가져와 로컬 서버의 릴레이 로그로 저장하는 역할 담당
	- `SHOW REPLICA STATUS` or `SHOW SLAVE STATUE` 로 스레드 상태 확인 가능
- Replica SQL 스레드 : I/O 스레드에 의해 작성된 이벤트를 읽고 실행하는 역할
	- `SHOW REPLICA STATUS` or `SHOW SLAVE STATUE` 로 스레드 상태 확인 가능

복제가 시작되면 레플리카 서버는 세 가지 유형의 데이터를 생성하고 관리한다.
- 릴레이 로그 : 레플리케이션 I/O 스레드에 의해 작성되는 파일. 소스 서버의 이벤트(트랜잭션) 정보가 저장된다.
- 커넥션 메타데이터 : 레플리케이션 I/O 스레드가 소스 서버에 접근할 때 필요한 정보들이 담겨있다.
	- 연결에 필요한 DB 접속 정보
	- 마지막으로 반영한 소스 서버의 바이너리 로그 파일명과 파일 내 위치
	- mysql.slave_master_info 테이블에 저장된다
	- FILE or TABLE 형태 중 하나를 택하여 관리할 수 있다 (기본은 TABLE)
- 어플라이어 메타데이터 : 레플리케이션 SQL 스레드가 복제 서버에 이벤트를 반영할 때 필요한 정보들이 담겨있다.
	- 마지막으로 반영한 마지막 릴레이 로그 파일명과 파일 내 위치
	- mysql.slave_relay_log_info 테이블에 저장된다
	- FILE or TABLE 형태 중 하나를 택하여 관리할 수 있다 (기본은 TABLE)


# 복제 타입 #anki
바이너리 파일 기반으로 복제가 구현된 것은 맞지만, `로그에 기록된 변경 내역을 식별하는 방식`에 따라 복제 방식이 다르다.
- 파일 위치 기반 복제
- 글로벌 트랜잭션 ID 기반 복제

## 파일 위치 기반 복제 #anki
레플리카 서버에서 소스 서버의 바이너리 로그 파일명과 파일 내에서의 위치(Offset or Position)로 개별 바이너리 로그 이벤트를 식별해서 복제가 진행되는 방식
- 소스 서버에서 발생한 각 이벤트에 대한 식별을 파일명 + 파일 내 위치 값을 통해 식별한다
	- 동기화 시에 어떤 지점부터 시작할지 구분할 수 있다
	- `SHOW MASTER STATUS` 명령으로 바이너리 로그 파일 정보를 확인할 수 있다. (파일명, 위치 등)
- 고유한 server_id를 가지고 복제에 참여해야 한다. 각 서버를 구분해야 어떤 이벤트를 적용하고 말지 알 수 있다
	- 바이너리 로그 이벤트에 server_id도 저장되기에, 레플리카 서버에서 발생된 이벤트는 무시할 수 있다

파일 위치 기반 복제는 다음과 같은 단점이 있다.
- 복제에서 각각의 이벤트가 파일명 + 파일 내 위치 값으로 식별되는데, 이는 소스 서버에 해당하는 내용이고 래플리가 서버에서도 같은 파일명에 같은 파일 내 위치값으로 해당 이벤트가 저장된다는 보장이 없다.
	- 서로 호환되는 정보를 공유하고 있지 않기에 slave가 master가 되어야하는 상황이 될 때 정보가 맞지않아 동기화에 문제가이 생긴다. 즉, 복제 토폴로지 변경에 어려움이 생긴다. (장애가 발생했을 때 master-slave 권한 변경)
	- 이를 해결하기 위해 GTID 기반 복제가 등장함.

복제 도중에 다음과 같은 문제가 발생할 수 있다.
- 레플리카 서버에서 소스 서버로 넘어온 트랜잭션이 제대로 실행되지 못하고 에러가 발생하여 복제가 멈추는 경우
	- 경우
		- 사용자 실수 (대부분)
			- 중복 키 에러
		- MySQL 서버의 비정상 종료와 같은 예기치 못한 문제
	- 해결
		- 문제가 되는 트랜잭션을 건너뛰도록 만들기
			- `sql_slave_skip_counter 시스템 변수`를 이용하기. 해당 변수가 1로 설정되면 실제로 DML 쿼리 문장 하나를 무시하는 게 아니라 현재 이벤트를 포함한 이벤트 그룹을 무사한다. (트랜잭션이 하나의 이벤트 그룹. 트랜잭션이 없다면 DML 문장 하나하나가 이벤트 그룹.)
		- 수동 복구. 최악은 다시 레플리카 서버 구성하는 것


## 글로벌 트랜잭션 아이디(GTID) 기반 복제 #anki
복제에 참여한 모든 서버에게 고유하도록 각 이벤트에 부여된 식별 값을 GTID라고 하며, 이를 기반으로 진행되는 복제를 GTID 기반 복제라고 한다.

GTID는 다음과 같은 특징을 지닌다.
- 물리적인 내용과는 무관한 논리적인 단위로 생성된다.
	- 서버에서 커밋된 각 트랜잭션과 연결된 고유 식별자로 복제에 참여한 모든 서버에서 고유하다.
- GTID는 커밋되어 바이너리 로그에 기록된 트랜잭션에 한에서만 할당된다.
	- 데이터 읽기(SELECT 쿼리) 및 `sql_log_bin 설정`이 비활성화돼 있는 상태에서 발생한 트랜잭션은 GTID가 할당되지 않는다.

GTID 형식은 다음과 같다.
> source_id:transaction_id
>
>ex) abc00000-0000-0000-0000-000011111111:1
>ex) abc00000-0000-0000-0000-000011111111:2-5
>ex) abc00000-0000-0000-0000-000011111111:1-5:18:99-103

- source_id : 소스서버를 식별하기 위한 값으로, server_uuid 시스템 변수값을 사용한다.
- transaction_id : 1부터 단조 증가하는 값으로, 트랜잭션 순서대로 부여된다.
	- GTID set을 표현하기 위해 범위로 연속적으로 표현될 수 있다.

현재 사용 중인 GTID 조회하는 방법은 3가지가 있다.
- SELECT * FROM mysql.gtid_executed;
- SHOW GLOBAL VARIABLES 'gtid_executed'
- SHOW MASTER STATUS \\G

`mysql.gtid_executed 테이블`은 단순 저장 목적 외에 중요한 역할을 수행한다.
- 레플리카 서버에서 바이너리 로그가 비활성화돼 있는 상태에서 GTID 기반의 복제를 사용할 수 있게하기
- 바이너리 로그 손실됐을 때 GTID 값 보존하기

그리고 해당 테이블은 계속 쌓이기에 필요한 시점마다 range로 압축시킨다.
> source_id:88, source_id:89, source_id:90 = source_id:88-90


### 글로벌 트랜잭션이 필요한 이유 예시

![[IMG-1380.jpg]]
B는 쿼리 분산용으로, C는 통계용으로 사용하고 있다고 가정해보자
B는 소스 서버와 완전 동기화된 상태이고, C는 아직 최신 이벤트까지 동기화되지 않았다.
이때 소스 서버 A에 장애가 발생하여 B가 promotion 되었다고 생각해보자.

![[IMG-1381.jpg]]
B는 최신 이벤트까지 반영된 상태이기에 데이터 동기화에는 문제가 없지만, A가 받던 트래픽을 모두 수용해야 하기에 과부하 상태가 될 것이다.
이 때 할 수 있는 선택지는 쿼리 분산을 위해 C를 이용하는 것인데, C는 완전 동기화가 되지 않았기에 A가 죽은 시점에서 B만을 가지고 복제를 최종 시점까지 할 방법이 없다. (C 입장에서는 A의 파일명과 offset만을 알고 있기 때문)
다만, B의 릴레이 로그에는 소스 서버의 바이너리 로그 위치가 기록되어 있으므로 복구가 가능하지만, 릴레이로그는 불필요해지는 시점에 삭제가 되기에 제한적인 방법이다.

![[IMG-1382.jpg]]
GTID가 적용된 상황을 가정해보자.
마찬가지로 A가 장애가 발생했고, B로 promotion이 된다고 했을 때 C를 분산 쿼리 용도로 사용할 수 있을까?

![[IMG-1383.jpg]]
당연히 가능하다.
GTID로 개별 이벤트를 구분할 수 있기 때문에 C입장에서 B의 바이너리 로그 이벤트를 가져와서 동기화 시키면 그만이다.


# 복제 포멧
변경 이벤트들이 바이너리에 어떤 형태로 저장되는지 2가지 분류가 존재한다.
- SQL 문을 기록하는 statement 포맷
- 변경된 데이터 자체를 기록하는 row 포맷
- 두 방식을 혼합한 포맷

## Statement 포맷

mysqlbinlog 도구로 바이너리 로그 안에 있는 내용을 확인해보면 다음과 같이 SQL문을 그대로 확인할 수 있다.
```
shell> mysqlbinlog -v log_file
shell> mysqlbinlog -v --base64-output=DECODE-ROWS log_file

...

# at 218
#080828 15:03:08 server id 1  end_log_pos 258   Write_rows: table id 17 flags: STMT_END_F

BINLOG '
BBCGGAAAANoAAAAAABEAAAAAAAAABHRlc3QAAXQAAwMPCgIUAAQ=
BCKAAAAAIBAAAQABEAAAAAAAEAA//8AQAAAAVhcHBsZQ==

'/*!*/;

### INSERT INTO Temp
### SET
###   @1=10
###   @2='yeah'
...
```

장점
- 감사 목적에 활용하기 쉽다. (실행된 SQL문을 그대로 확인할 수 있으므로)
- row 방식에 비해 상대적으로 저장공간에 대한 부담이 적다.
	- 고로 레플리카 서버와 복제할 때도 좀 더 빠르게 처리될 수 있다.

단점
- Non-Deterministic 한 쿼리가 실행된 경우 복제 시 소스 서버와 레플리카 서버 간에 데이터 일관성을 해칠 수 있다.
	- rand(), uuid() 등의 함수는 실행시점마다 달라진다. SQL 문이 아닌 실행된 결과 데이터가 필요하다.
	- 동일한 파라미터를 입력하더라도 결괏값이 달라질 수 있는 사용자 정의 함수나 스토어드 프로시저도 마찬가지
- row 포맷에 비해 데이터에 락을 더 많이 건다.
	- 레플리카 서버에 반영되는 시점에 SQL을 처리할 때 락이 필요.
	- 뒤에 이야기 하겠지만, row는 데이터 자체는 넘기는 방식이라 락을 더 적게 점유하고 처리속도도 빠르다.

제한 사항
- isolation level이 REPEATABLE-READ 이상이 요구된다.
	- 그 이하에서는 단일 트랜잭션에서도 각 쿼리가 실행되는 시점마다 데이터 스냅샷이 달라질 수 있어서, 레플리카 서버와 소스 서버 사이의 데이터가 달라질 수 있다.

## Row 포맷
데이터 변경이 발생했을 때 변경된 값 자체가 바이너리 로그 파일에 기록되는 방식

장점
- `어떤 형태의 쿼리가 실행됐든 간에 데이터를 일관되게 만들어주는 가장 안전한 방식` 이다.
- 쿼리 실행이 아닌 데이터 반영이므로 어떤 이벤트이건 더 적은 락을 점유한다.
- 처리속도가 빠르다.

단점
- 변경된 데이터가 모두 기록되므로 파일 크기가 단시간에 매우 커질 수 있다.
	- 저장공간 vs 처리속도의 트레이드 오프
	- 변경된 데이터 수가 적어도 BLOB 형태의 큰 데이터라면 마찬가지로 커질 수 있다.
- 감사가 힘들어진다.
	- `mysqlbinlog 사용시 -v 옵션`을 켜서 데이터를 기반으로 유사 SQL(pseuudo SQL)을 볼 수 있다.
	- 실행된 SQL 쿼리를 보고 싶다면, 소스 서버에서 `binlog_rows_query_log_events 시스템 변수를 활성화`한 후 `mysqlbinlog 사용시 -vv 옵션`을 명시하면 가능하다. 

제한사항
- isolation level에 제한은 없다.
- 다만 계정 관리, 테이블 관리, 뷰 관리, 트리거 관리와 같은 DDL 문은 statement 포맷으로 기록된다. (row로 불가)

## Mixed 포맷
두 가지 포맷을 혼합하여 사용하는 방식
기본적으로 statement 방식을 사용하되, 실행된 쿼리와 스토리지 엔진 종류에 따라 필요 시 자동으로 row 포맷을 사용한다.
Non-Deterministic 한 쿼리 유형의 경우 row 포맷으로 저장하게 된다.
binlog_format 시스템 변수를 MIXED 값으로 지정하면 사용할 수 있다.

 engine 내부 기준을 통해 포맷을 번갈아가면서 사용하므로 사용자가 statment를 기대했지만 row 포맷으로 기록되는 경우가 생길 수 있어 무조건 좋은 방법이라고 볼 수 없다. 



# 복제 동기화 방식
TODO: 시간 괜찮으면 정리

